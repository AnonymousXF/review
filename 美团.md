#### join和union的区别

* **join**：是两张表做交连后里面条件相同的部分记录产生一个记录集
* **union**：产生的两个记录集(列结构相同，列数相同)并在一起，成为一个新的记录集

Table1数据库表

| ColumnA | ColumnB | ColumnC |
| ------- | ------- | ------- |
| X1      | Y1      | Z1      |
| X2      | Y2      | Z2      |
| X3      | Y3      | Z3      |

Table2数据库表

| ColumnA | ColumnD | ColumnE |
| ------- | ------- | ------- |
| X1      | D1      | E1      |
| X2      | D2      | E2      |
| X3      | D3      | E3      |

Table1和Table2表共有的列为ColumnA，如果通过ColumnA列的值连接Table1和Table2两个表，即连接条件为Table1.ColumnA=Table2.ColumnA，此时得到的连接结果如下所示。

连接Table1和Table2表

| ColumnA | ColumnB | ColumnC | ColumnD | ColumnE |
| ------- | ------- | ------- | ------- | ------- |
| X1      | Y1      | Z1      | D1      | E1      |
| X2      | Y2      | Z2      | D2      | E2      |
| X3      | Y3      | Z3      | D3      | E3      |

上述连接过程的实现代码可表示如下：**SELECT * FROM Table1 JOIN Table2 ON Table1.ColumnA=Table2.columnA**





Table3数据库表

| ColumnA | ColumnB | ColumnC |
| ------- | ------- | ------- |
| X1      | Y1      | Z1      |
| X2      | Y2      | Z2      |
| X3      | Y3      | Z3      |

Table4数据库表

| ColumnA | ColumnD | ColumnE |
| ------- | ------- | ------- |
| X4      | Y4      | Z4      |
| X5      | Y5      | Z5      |
| X6      | Y6      | Z6      |

Table3表和Table4表具有相同的列结构，列数也要相同，列名可以不同，以第一个表的列名为新表的列名，因此可以使用UNION运算符连接两个表的记录集，得到的连接结如下所示。

使用UNION连接Table3表和Table4表的记录

| ColumnA | ColumnB | ColumnC |
| ------- | ------- | ------- |
| X1      | Y1      | Z1      |
| X2      | Y2      | Z2      |
| X3      | Y3      | Z3      |
| X4      | Y4      | Z4      |
| X5      | Y5      | Z5      |
| X6      | Y6      | Z6      |

上述连接过程的实现代码可表示如下：**SELECT * FROM Table3 UNION SELECT *FROM Table4**





#### get和post的区别

GET和POST本质上都是TCP连接，由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同（参数位置）。

简单的说：GET产生一个TCP数据包;POST产生两个TCP数据包。

* 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
* 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)；



#### HashMap和HashTable的区别

这里简单分析他们的区别。

　　1.HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap这个区别就像Vector和ArrayList一样。

　　2.HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。

　　3.HashTable有一个contains(Object value)，功能和containsValue(Object value)功能一样。

　　4.HashTable使用Enumeration，HashMap使用Iterator。 以上只是表面的不同，它们的实现也有很大的不同。

　　5.HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

　　6.哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值，而且用与代替求模。





```c++
//求数组中和为特定值的所有组合
#include<iostream>  
using namespace std;  
#include<list>  
namespace MS100P_21  
{  
    //递归  
    void helper(int index, int m, int n, list<int>& record)  
    {  
        if (index <= n)  
        {  
            if (index == m)  
            {  
                helper(index + 1, m, n, record);      
                record.push_back(index);  
                for (list<int>::iterator iter = record.begin(); iter != record.end(); iter++)  
                    cout << *iter << ' ';  
                cout << endl;  
                record.pop_back();  
            }  
            if (index < n)  
            {  
                helper(index + 1, m, n, record);  
                record.push_back(index);  
                helper(index + 1, m - index, n, record);  
                record.pop_back();  
            }  
  
        }  
    }  
    void findCombination(int m, int n)  
    {  
        list<int> record;  
        helper(0, m, n, record);  
    }  
  
    void test()  
    {  
        findCombination(10, 20);  
    }  
}  
  
int _tmain(int argc, _TCHAR* argv[])  
{  
    MS100P_21::test();  
    return 0;  
}  
```



```c++
//全排列
#include <iostream>
using namespace std;
void swap(int &a,int &b){
    int temp=a;
    a=b;
    b=temp;
}
void perm(int list[],int low,int high){
    if(low==high){   //当low==high时,此时list就是其中一个排列,输出list
        for(int i=0;i<=low;i++)
            cout<<list[i];
        cout<<endl;
    }else{
        for(int i=low;i<=high;i++){//每个元素与第一个元素交换
            swap(list[i],list[low]); 
            perm(list,low+1,high); //交换后,得到子序列,用函数perm得到子序列的全排列
            swap(list[i],list[low]);//最后,将元素交换回来,复原,然后交换另一个元素
        }
    }
}
int main()
{

int list[]={1,2,3};
perm(list,0,2);
return 0;
}
```

