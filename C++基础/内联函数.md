C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：

```c++
inline int max(int a, int b)
{
 return a > b ? a : b;
}
```

则调用： cout<<max(a, b)<<endl;

在编译时展开为： cout<<(a > b ? a : b)<<endl;

从而消除了把 max写成函数的额外执行开销。



**内联与宏**

* 宏代码的缺点是容易出错，预处理器在拷贝宏代码时常常产生意想不到的边际效应。例如：

  ```c++
  #define MAX(a,b)  (a)>(b)?(a):(b)

  //语句
  result = MAX(i,j) + 2;

  //被预处理器扩展为
  result = (i)>(j)?(i):(j) + 2;

  //由于运算符 + 比运算符 ?: 的优先级高，所以上述语句不等价于期望的：
  result = ((i)>(j)?(i):(j)) + 2;
  //而是
  result = (i)>(j)?(i):((j)+2);
  ```

* 宏的另一个缺点是不可以调试，但内联函数是可以调试的。

* 宏代码无法操作类的私有数据成员。

* 函数被内联后，编译器就可以通过上下文相关的优化技术对结果代码执行更深入的优化。





##### 内联函数

C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。

```c++
inline void Foo(int x, int y);  //inline仅与函数声明放在一起,不构成内联函数  
void Foo(int x, int y)
{
 ...
} 
//====================================
void Foo(int x, int y);   
inline void Foo(int x, int y)   //inline与函数定义体放在一起,构成内联函数
{
 ...
} 
```

定义在类声明之中的成员函数将自动地成为内联函数，例如：

```c++
class A
{  
public:
 void Foo(int x, int y) { ... }   // 自动地成为内联函数  
} 
```

内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。

当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。



```c++
//A.h
class A
{
public:
 A(int a, int b) : a(a),b(b){}
 int max();
private:
 int a;
 int b;
};

//A.cpp
#include "A.h"
inline int A::max()
{
 return a > b ? a : b;
}


//Main.cpp
#include <iostream>
#include "A.h"
using namespace std;
inline int A::max()
{
 return a > b ? a : b;
}
int main()
{
 A a(3, 5);
 cout<<a.max()<<endl;
 return 0;
}

//一切正常编译，输出结果：5
```

倘若你在Main.cpp中没有定义max内联函数，那么会出现链接错误：

error LNK2001: unresolved external symbol "public: int __thiscall A::max(void)" (?max@A@@QAEHXZ)main.obj
找不到函数的定义，所以内联函数可以在程序中定义不止一次，只要 inline 函数的定义在某个源文件中只出现一次，而且在所有源文件中，其定义必须是完全相同的就可以。

在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译。



内联函数仅仅是对编译器的内联建议，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。

**虚函数不允许内联。**