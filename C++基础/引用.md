#### 引用

引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。

引用的声明方法：类型标识符 &引用名 = 目标变量名；

* 引用的类型标识符指的是目标变量的类型。
* 声明引用时，必须对其进行初始化。
* 一旦引用被初始化，就不能改变引用的关系
* 不能有NULL引用，引用必须与合法的存储单元关联
* 不能定义引用类型的引用。
* 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
* 不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。



#### 引用的应用

##### 1、引用作为参数

```c
 1 #include<iostream.h>
 2 ////此处函数的形参p1, p2都是引用 
 3 void swap(int &p1,int &p2){
 4     int p=p1;
 5     p1=p2;
 6     p2=p;
 7 }

 8 void main(){
 9     int a,b;
10     cin>>a>>b;//输入a,b两个变量的值
11     swap(a,b);//直接以a和b作为实参调用swap函数
12     cout<<"a="<<a<<",b="<<b<<endl;
13 }
```

> **由上例可以看出：**
>
> （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
>
> 　　**（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。**
>
> 　　（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
>
>  
>
> **如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。**



##### 2、常引用

​        常引用声明方式：const  类型标识符  &引用名 = 目标变量名；

　　用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。

```c
const int a = 100;
const int &refa = a;   //正确：引用和被引用都是const类型
int &ref2 = a;    //错误：引用不是const类型
```

const引用可以读取但不可以修改引用对象，任何对const引用进行赋值都是不合法的，它适用于指向const对象的引用，而非const的引用不适用于指向const对象的引用，可以修改引用和被引用对象的值。

```c
// 假设有如下函数声明：
string foo();
void bar(string &s);
// 那么下面的表达式将是非法的：
bar(foo());
bar("hello world");

//原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
```

**引用型参数应该在能被定义为const的情况下，尽量定义为const 。**



##### 3、引用作为返回值

要以引用返回函数值，则函数定义时要按以下格式：

　　　　**类型标识符  &函数名 （形参列表及类型说明）**

​               **｛  函数体  ｝**

说明：

（1）以引用返回函数值，定义函数时需要在函数名前加&

**（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。**

```c
 1 #include<iostream.h>
 2 float temp;//定义全局变量temp
 3 float fn1(float r);//声明函数fn1
 4 float &fn2(float r);//声明函数fn2 r
 5 float fn1(float r){//定义函数fn1，它以返回值的方法返回函数值
 6     temp=(float)(r*r*3.14);
 7     return temp;
 8 }
 9 float &fn2(float r){//定义函数fn2，它以引用方式返回函数值
10     temp=(float)(r*r*3.14);
11     return temp;
12 }
13 void main(){
14     float a=fn1(10.0);//第1种情况，系统生成要返回值的副本（即临时变量）
15 //    float &b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定）
16 /* 
17     编译错误：cannot convert from 'float' to 'float &'
18     A reference that is not to 'const' cannot be bound to a non-lvalue
19 */
20     //不能从被调函数中返回一个临时变量或局部变量的引用
21     float c=fn2(10.0);//第3种情况，系统不生成返回值的副本
22     //可以从被调函数中返回一个全局变量的引用
23     float &d=fn2(10.0); //第4种情况，系统不生成返回值的副本
24     cout<<"a="<<a<<",c="<<c<<",d="<<d<<endl;
25     //a=314,c=314,d=314
26 }
```

> 引用作为返回值，必须遵守以下规则：
>
> * **不能返回局部变量的引用。**
> * **不能返回函数内部new分配的内存的引用。**
> * **可以返回类成员的引用，但最好是const。**
> * 引用与一些操作符的重载：流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << \"hello\" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
> * 在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用。

```c
 //测试用返回引用的函数值作为赋值表达式的左值
 1 #include<iostream.h>
 2 int &put(int n);
 3 int vals[10];
 4 int error=-1;
 5 void main(){
 6     put(0)=10;//以put(0)函数值作为左值，等价于vals[0]=10;
 7     put(9)=20;//以put(9)函数值作为左值，等价于vals[9]=20; 
 8     cout<<vals[0]<<endl;//10
 9     cout<<vals[9]<<endl;//20
10 }
11 int &put(int n){
12     if(n>=0 && n<=9)
13         return vals[n];
14     else{
15         cout<<"subscript error";
16         return error;
17     }
18 }
```



##### 4、引用和多态

**引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。**

```c++
class  A;
class  B:public  A{ ... ... }
B  b;
A  &Ref = b;//用派生类对象初始化基类对象的引用

//Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。
```



#### 引用总结

* 在引用的使用中，单纯给某个变量取个别名是毫无意义的，**引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。**
* **用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。**
* **引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。**
* **使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。**



#### 引用与指针

##### 相同点：

* 都是地址的概念：指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。



##### 区别：

* 指针是一个实体，而引用仅是个别名；
* 引用使用时无需解引用（*），指针需要解引用；
* 引用只能在定义时被初始化一次，之后不可变；指针可变；
* 引用不能为空，指针可以为空；
* “sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身的大小；
* 指针和引用的自增（++）运算意义不一样；



##### 联系：

* 引用在语言内部用指针实现
* 对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。

