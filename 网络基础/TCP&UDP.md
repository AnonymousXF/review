**TCP（Transmission Control Protocol，传输控制协议）**

##### TCP固定首部字段结构（20字节），后面还有40字节的可选字段，是可变长的，最大为40字节

* 源端口号（2字节）
* 目的端口号（2字节）
* 序列号（4字节）
* 确认序列号（4字节）
* 4 bit 首部长度 +6 bit 保留字段 + 6 bit Flag字段（URG、ACK、PSH、RST、SYN、FIN）（共2字节）
* 窗口大小（2字节）
* 校验和（2字节）
* 紧急指针（2字节）

> 说明：
>
> * 4 bit首部长度：标识TCP头部有多少个字（32bit，4字节）。因为4bit最大能表示15，所以TCP首部最长时60字节。
> * 6 bit Flag分别表示：
>   * URG：表示紧急指针是否有效。
>   * ACK：表示确认号是否有效，称携带ACK标志的TCP报文段为确认报文段。
>   * PSH：提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）。
>   * RST：表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。
>   * SYN：表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。
>   * FIN：表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。
> * 紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。



##### TCP三次握手（建立连接）

![](TCP建立连接_三次握手.png)

* 第一步：客户端发出连接请求，发送SYN = 1以及序列号 seq = x
* 第二步：服务器收到连接请求，进行回复确认，向客户端发送 SYN = 1，ACK = 1，seq = y，ack = x + 1
* 第三步：客户端进行再一次的确认，回复ACK = 1，seq = x + 1，ack = y + 1



> 为什么要采用三次握手，而不是两次握手？（即为什么要进行两次确认）
>
> * 采用三次握手是为了防止客户端发送的失效的连接请求报文突然又传送到服务器，因而产生错误。失效的连接请求报文段是指：客户端A发出的连接请求没有收到服务器B的确认，于是经过一段时间后，客户端A又重新向服务器B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，客户端A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到服务器B，服务器B以为是客户端A又发起的新连接，于是服务器B同意连接，并向客户端A发回确认，但是此时客户端A根本不会理会，服务器B就一直在等待客户端A发送数据，导致服务器B的**资源浪费**。



##### TCP四次挥手（断开连接）

![](TCP断开连接_四次挥手.png)

* 第一步：客户端A（主动关闭方）发送FIN = 1、seq = u，用来关闭主动方到被动关闭方的数据传送，即客户端A不再发送数据（**但仍然可以接受数据**）。
* 第二步：服务器B（被动关闭方）收到FIN包后，发送ACK = 1、seq = v、ack = u + 1给客户端A，确认收到释放连接请求。
* 第三步：A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是发送FIN = 1、seq = w、ack = u + 1，用来关闭被动关闭方到主动关闭方的数据传送。
* 第四步：A收到FIN后，发送ACK = 1、seq = u + 1、ack = w + 1给B，确认收到释放链接请求。至此，完成四次挥手。



> 为什么TCP断开连接要四次挥手？
>
> * TCP是全双工模式，接收到FIN时意味着将没有数据再发来，但还是可以	继续发送数据。对于A（客户端）、B（服务器）双方，每一方都要进行发送FIN释放连接请求以及确认对方的释放连接请求，因此共需要4次。
>
>
>
> 为什么要设置TIME_WAIT？
>
> * B向A发送 FIN = 1 的释放连接请求，A需要回复ACK，如果这个ACK包丢失，B没有收到ACK包，会进行超时重传，这样A在TIME_WAIT还能够接受到B重发的FIN包，并对其进行确认回复。（A收到FIN请求后，TIME_WAIT会重新计时）。
>
>
>
> 大量TIME_WAIT产生的原因及解决办法。
>
> * 原因：对于基于TCP的HTTP协议，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态。
> * 解决办法：
>   * 开启socket重用，允许将TIME_WAIT的socket重新用于TCP连接
>   * 开启快速回收





##### 出现RST包的原因？

RST：TCP首部中的6个Flag其中之一，表示重置连接、复位连接。

原因：

* 服务器端口未打开而客户端来连接
* 在一个已经关闭的Socket上收到数据：客户端在服务端已经关闭掉socket后，仍然在发送数据，这时服务端会产生RST。
* 请求超时
* 提前关闭





##### TCP数据传输的可靠性体现在哪？

* TCP将数据截断为合理的长度进行发送。
* 超时重传。
* 对于收到的请求，给出确认响应。
* 校验时出错，丢弃报文段，不给出响应，TCP发送数据端，超时会重发数据。
* 对失序数据进行重新排序，然后才交给应用层。
* 对于重复数据，能够丢弃重复数据。
* TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出。







**UDP（User Data Protocol，用户数据报协议）**

* **UDP是一个非连接的协议**，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
* 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
* UDP信息包的首部很短，只有**8个字节**，相对于TCP的20个字节首部的额外开销很小。
* 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
* UDP使用**尽最大努力交付，**即不保证可靠交付，因此主机不需要维持复杂的链接状态表。
* UDP是**面向报文**的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

我们经常使用“**ping**”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

##### UDP首部字段结构（共8字节）

* 源端口（2字节）
* 目的端口（2字节）
* 长度（UDP报文的整个大小，最小为8字节，即仅为首部）（2字节）
* 校验和（2字节）





##### TCP和UDP的区别

* TCP是面向连接的协议；UDP是无连接的协议。
* TCP提供交付保证，如果消息在传输过程中丢失，消息将会被重发；UDP不提供任何交付保证。
* TCP保证了消息的有序性；UDP不提供序列行的保证。
* TCP不保存数据的边界；而UDP保证。
* TCP速度比较慢；UDP速度比较快。
* TCP被认为是重量级的协议；UDP相对地被认为是轻量级的协议。
* TCP头部较长，为20个字节；UDP头部较短，为8个字节。
* TCP具有流量控制；UDP不能进行流量控制。




##### 基于TCP的一些协议

* FTP：文件传输协议，使用**21**端口
* Telnet：远程登录服务协议，使用**23**端口
* SMTP：邮件传送协议，使用**25**端口
* POP3：与SMTP对应，用于邮件接收，使用**110**端口
* HTTP：web服务器超文本传输协议，默认使用**80**端口



##### 基于UDP的一些协议

* DNS：域名解析服务，使用**53**端口
* SNMP：简单网络管理协议，使用**161**端口
* TFTP：简单文件传输协议，使用**69**端口
* DHCP：动态主机配置协议，默认使用**67/68**端口